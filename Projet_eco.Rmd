---
title: "R Notebook"
output: html_notebook
---

Importation des librairies:
```{r}
#install.packages("MatchIt")
library(MatchIt)
#install.packages('Rcpp')
library(Rcpp)
library(dplyr)
#install.packages("glmnet")
library(glmnet)
library(arm)
```

Récupération des données
```{r}
hepat <- read.csv('C:/Users/maxfou/Desktop/hepatitisc.csv')
```

Le but est de voir s'il existe des critères qui favorisent l'apparition d'une cirrhose, le groupe de contrôle seront les donneurs de sang sains (Category=0) et le groupe de traitement est celui avec une cirrhose (Category=3)

On récupère les noms des colonnes pour les appeler plus tard:

```{r}
names(hepat)
```


On commence par nettoyer et filtrer les données, i.e enlever les N.A et le autres catégories:
Tout d'abord le filtrage:

```{r}
filtered=hepat %>% filter(Category == "0=Blood Donor" | Category == "3=Cirrhosis" )
filtered
```
Nettoyage:

```{r}
clean=na.omit(filtered)
clean
```

On vérifie le nombre d'individus dans les deux groupes:
```{r}
occurences<-table(unlist(clean))
occurences["3=Cirrhosis"]
occurences["0=Blood Donor"]
nrow(clean)
```
Parmi les 526 donneurs sains, on va en trouver 24 à apparier avec les membres du groupe de cirrhose.

On crée une colonne booléenne pour la classe (sain ou cirrhose):
```{r}
Classe=c()
for (i in  1:nrow(clean)){
  Classe=append(Classe,as.integer(clean[i,"Category"]=="3=Cirrhosis"))
}
Classe
```

Petit détail des opérations effectuées ci-dessus:
```{r}
clean[540,"Category"]
a=c()
b=as.integer(clean[540,"Category"]=="3=Cirrhosis")
c=append(a,b)
c=append(c,b)
a
b
c
```
On ajoute Classe au dataset:
```{r}
fin=cbind(clean,Classe)
fin
```



On utilisera en données quantitatives : "Age", "ALB", "ALP", "ALT", "AST", "BIL", "CHE", "CHOL", "CREA", "GGT" et "PROT" 
(soit 11 variables) pour expliquer "Classe"
```{r}
m.out = matchit (Classe ~ Age + ALB + ALP + ALT + AST + BIL + CHE + CHOL + CREA + GGT + PROT, data=fin, method="nearest", ratio=1)
summary(m.out)
```

Affichage 
```{r}
plot(m.out, type="jitter")
plot(m.out, type="hist")
```





Essai avec un ratio de 2 (on apparie un élément traité avec 2 éléments contrôle)
```{r}
m2.out = matchit (Classe ~ Age + ALB + ALP + ALT + AST + BIL + CHE + CHOL + CREA + GGT + PROT, data=fin, method="optimal", ratio=8)
summary(m2.out)
```

Affichage 
```{r}
plot(m2.out, type="jitter")
plot(m2.out, type="hist")
```

Autre distance utilisée: 
```{r}
man= matchit (Classe ~ Age + ALB + ALP + ALT + AST + BIL + CHE + CHOL + CREA + GGT + PROT, data=fin, method="nearest", distance = "mahalanobis", ratio=1)
summary(man)
```

Affichage des qq-plot des deux groupes avant et après appariement
```{r}
plot(man, type="qq", interactive=FALSE)
```
Affichage des densités avant et après appariement
```{r}
plot(man, type="density", interactive=FALSE)
```
Affichage des ecdf (empirical cumulative distribution function: pour n éléments, saute de 1/n à chaque point de l'échantillon )
```{r}
plot(man, type="ecdf", interactive=FALSE)
```

Tentative de régression linéaire pénalisée avec glmnet car séparation parfaite de Classe empêche régression linéaire
```{r}
df=fin[c("Age", "ALB", "ALP", "ALT", "AST", "BIL" ,"CHE" ,"CHOL" ,"CREA" ,"GGT", "PROT")]
class(df)
mat= as.matrix(df)
class(mat)
class(Classe)
ps<- glmnet(mat, Classe , family = binomial())
summary(ps)
```

```{r}
plot(ps)
print(ps)
```
```{r}
coef(ps,s=0.01)
```

Test de distances différentes
```{r}
test = matchit (Classe ~ Age + ALB + ALP + ALT + AST + BIL + CHE + CHOL + CREA + GGT + PROT, data=fin, method="nearest", distance = "lasso", ratio=4)
summary(test)
plot(test, type="jitter")
plot(test, type="hist")
```
```{r}
test2 = matchit (Classe ~ Age + ALB + ALP + ALT + CHE + CHOL + GGT + PROT, data=fin, method="optimal", distance = "ridge", ratio=4)
summary(test2)
plot(test2, type="jitter")
plot(test2, type="hist")
```
```{r}
test2 = matchit (Classe ~ Age + ALB + ALP + ALT + CHE + CHOL + GGT + PROT, data=fin, method="optimal", distance = "bart", ratio=3)
summary(test2)
plot(test2, type="jitter")
plot(test2, type="hist")
```

```{r}
test2 = matchit (Classe ~ Age + ALB + ALP + ALT + CHE + CHOL + GGT + PROT, data=fin, method="optimal", distance = "elasticnet", ratio=3)
summary(test2)
plot(test2, type="jitter")
plot(test2, type="hist")
```

```{r}
test2 = matchit (Classe ~ Age + ALB + ALP + ALT + CHE + CHOL + GGT + PROT, data=fin, method="optimal", distance = "glm", ratio=1)
summary(test2)
plot(test2, type="jitter")
plot(test2, type="hist")
```
```{r}
test2 = matchit (Classe ~ Age + ALB + ALP + ALT + CHE + CHOL + GGT + PROT, data=fin, method="optimal", distance = "rpart", ratio=5)
summary(test2)
plot(test2, type="jitter")
plot(test2, type="hist")
```
Test logit
```{r}
reg=glm(Classe ~ Age + ALB + ALP + ALT + AST + BIL + CHE + CHOL + CREA + GGT + PROT, data=fin, family="binomial")
summary(reg)
```



Test glmbayes
```{r}
bay=bayesglm(Classe ~ Age + ALB + ALP + ALT + AST + BIL + CHE + CHOL + CREA + GGT + PROT, data=fin, family="binomial")
summary(bay)
```



Autre méthode utilisée ("optimal")
```{r}
opt= matchit (Classe ~ Age + ALB + ALP + ALT + AST + BIL + CHE + CHOL + CREA + GGT + PROT, data=fin, method="optimal", distance="mahalanobis", ratio=1)
summary(opt)
```


Affichage des qq-plot des deux groupes avant et après appariement
```{r}
plot(opt, type="qq", interactive=FALSE)
```
Affichage des densités avant et après appariement
```{r}
plot(opt, type="density", interactive=FALSE)
```


Enlevons les variables les moins bien appariés, càd celles avec la plus grande Var. Ratio (ratio des variances):
```{r}
moins = matchit (Classe ~ Age + ALB + ALT + AST + CHE + CHOL + PROT, data=fin, method="nearest", ratio=1)
summary(moins)
```

Dataset 2:
```{r}

```

