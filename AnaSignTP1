"""
1) Créer un signal u(t) à impulsion périodique avec tau=T/2 et d'amplitude E ,t=[0,pas,T]
2) Le tracer en fonction du temps et "vérifier"
3) Algo de Fourier u(t)->(a0,an,bn)
4) Tracer le spectre de puissance (cn²/2) en fonction de n
5) Reconstruire le signal avec N harmoniques. Comparer avec u(t)
"""

import math
import numpy as np
import matplotlib.pyplot as plt

#1)
T=1 #Période
A=1 #Amplitude
tau=0.5 #Durée du pic

#signal

def signal(t):return np.sign(np.sin(2*np.pi*t/T))
te=np.linspace(-T,3*T,1000)

#2)
plt.plot(te, np.sign(signal(te)), 'or-', label = u"Signal echantillonne")
plt.grid()
plt.xlabel("Temps $t$")
plt.ylabel("Amplitude $x(t)$")
plt.legend()
plt.show()

#3) 
per=np.linspace(0,T,1000)
pas=per[1]-per[0]
#coefficients
def a(n):
    if n==0:
        return (1/T)*np.sum(signal(per)*np.cos(2*n*np.pi*per/T)*pas)
    else:
        return (2/T)*np.sum(signal(per)*np.cos(2*n*np.pi*per/T)*pas)
def b(n):
    return (2/T)*np.sum(signal(per)*np.sin(2*n*np.pi*per/T)*pas)

#signal construit en somme de cos et sin

def signal2(t,n):
    s=a(0)
    for i in range(1,n+1):
        s+=a(i)*np.cos(2*np.pi*i*t/T)+b(i)*np.sin(2*np.pi*i*t/T)
    return s

#Affichage
tps=np.linspace(-T,3*T,1000)
Pr=signal(tps)
Se=signal2(tps,20)
plt.plot(tps,Pr,'--',color="r")
plt.plot(tps,Se,':',color="b")

#4)
#coefficient c(n)
def c(n):
    cn=[]
    num=[]
    i=0
    for i in range(n):
        cn.append(np.sqrt(a(i)**2+b(i)**2))
        num.append(i)
    return num,cn

ni,ci=c(10)
plt.scatter(ni,ci)
#(cn**2)/2
plt.scatter(ni,[(cu**2)/2 for cu in ci])

#5)
